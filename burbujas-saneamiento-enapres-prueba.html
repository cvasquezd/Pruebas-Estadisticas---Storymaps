<!DOCTYPE html> 
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Evolución de Principales Indicadores de Saneamiento</title>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
  <style>
    html,body{height:100%;margin:0;background:#fff;font-family:system-ui,Arial}
    #wrap{position:relative;height:100vh;width:100vw}
    #chart{height:100%;width:100%}

    /* ===== Leyenda ===== */
    .legend-bar{
      position:absolute; left:50%; transform:translateX(-50%);
      top:46px; z-index:10; display:flex; gap:10px; align-items:center; pointer-events:auto;
    }
    .legend-trigger{
      font-size:12px;font-weight:600;color:#2563eb;
      background:rgba(255,255,255,.9); border:1px solid #e5e7eb; border-radius:999px;
      padding:4px 10px; cursor:default; box-shadow:0 2px 10px rgba(0,0,0,.05); user-select:none;
    }
    .legend-tip{
      position:absolute; left:50%; transform:translateX(-50%); top:28px;
      background:rgba(255,255,255,.96); backdrop-filter:saturate(130%) blur(2px);
      border:1px solid #e5e7eb; border-radius:12px; padding:10px 12px; min-width:220px; max-width:260px;
      box-shadow:0 6px 18px rgba(0,0,0,.08); font-size:12px; color:#374151; display:none; pointer-events:none;
    }
    .legend-tip h4{margin:0 0 6px 0;font-size:12px;font-weight:700;color:#111827}
    .lg-row{display:flex;align-items:center;gap:8px;margin:4px 0}
    .lg-chip{width:14px;height:14px;border-radius:3px;border:1px solid rgba(0,0,0,.08);flex:0 0 auto}
    .muted{color:#6b7280}
    .legend-trigger:hover + .legend-tip{display:block}

    /* ===== Segmentación + filtro (derecha) ===== */
    .seg-bar{
      position:absolute; right:160px; top:46px; z-index:10;
      display:flex; gap:6px; align-items:center; pointer-events:auto; flex-wrap:wrap;
      max-width:min(60vw, 700px); justify-content:flex-end;
    }
    .seg-btn, .dd-trigger{
      font-size:12px;font-weight:600;color:#111827;
      background:rgba(255,255,255,.9); border:1px solid #e5e7eb; border-radius:999px;
      padding:4px 10px; cursor:pointer; box-shadow:0 2px 10px rgba(0,0,0,.05);
      user-select:none; white-space:nowrap;
    }
    .seg-btn.active{ color:#2563eb; border-color:#bfdbfe; }

    /* ===== Desplegable departamentos ===== */
    .dd{ position:relative; margin-right:14px; }
    .dd-panel{
      position:absolute; top:110%; left:0;
      background:#fff; border:1px solid #e5e7eb; border-radius:12px;
      box-shadow:0 8px 24px rgba(0,0,0,.10);
      padding:10px; min-width:240px; max-height:240px; overflow:auto; display:none; z-index:20;
    }
    .dd.open .dd-panel{ display:block; }
    .dd-search{ width:100%; padding:6px 8px; border:1px solid #e5e7eb; border-radius:8px; margin-bottom:8px; font-size:12px; }
    .dd-list{ display:flex; flex-direction:column; gap:6px; }
    .dd-row{ display:flex; align-items:center; gap:8px; font-size:12px; }
    .dd-actions{ display:flex; justify-content:space-between; gap:8px; margin-top:8px; }
    .pill{ font-size:12px; padding:4px 8px; border:1px solid #e5e7eb; border-radius:999px; background:#fff; cursor:pointer; }
    .pill:hover{ border-color:#bfdbfe; }

    @media (max-width: 1024px){
      .seg-bar{ right:120px; top:56px; }
      .legend-bar{ top:56px; }
    }
  </style>
</head>
<body>
<div id="wrap">
  <div id="chart"></div>

  <!-- Segmentación + filtro -->
  <div class="seg-bar" aria-label="Controles">
    <div class="dd" id="regionDD">
      <button class="dd-trigger" id="regionTrigger">Filtrar Departamentos</button>
      <div class="dd-panel" id="regionPanel" role="listbox" aria-multiselectable="true">
        <input class="dd-search" id="regionSearch" placeholder="Buscar departamento…"/>
        <div class="dd-actions">
          <button class="pill" id="selAll">Seleccionar todo</button>
          <button class="pill" id="selNone">Limpiar</button>
        </div>
        <div class="dd-list" id="regionList"></div>
      </div>
    </div>

    <button class="seg-btn active" data-ambito="TOTAL">Total</button>
    <button class="seg-btn" data-ambito="URBANO">Urbano</button>
    <button class="seg-btn" data-ambito="RURAL">Rural</button>
  </div>

  <!-- Leyenda SOLO escala de color por continuidad -->
  <div class="legend-bar" aria-hidden="true">
    <div class="legend-trigger">Leyenda</div>
    <div class="legend-tip" role="tooltip" aria-label="Leyenda de colores según continuidad (horas)">
      <h4>Color por Continuidad (h)</h4>
      <div class="lg-row"><span class="lg-chip" style="background:#d00000"></span><span>&lt; 6 h</span></div>
      <div class="lg-row"><span class="lg-chip" style="background:#f40000"></span><span>6 – &lt; 12 h</span></div>
      <div class="lg-row"><span class="lg-chip" style="background:#ffb20f"></span><span>12 – &lt; 18 h</span></div>
      <div class="lg-row"><span class="lg-chip" style="background:#1dfc12"></span><span>18 – 24 h</span></div>
      <div class="lg-row"><span class="lg-chip" style="background:#9e9e9e"></span><span class="muted">Sin dato</span></div>
    </div>
  </div>
</div>

<script>
/* ===================== CONFIG ===================== */
const DOT_BORDER = { color:'#0f172a', width:0.1, type:'solid', opacity:0.90 };

const SERVICE_BASE = "https://pportalgis.vivienda.gob.pe/phtserver/rest/services/indicadores_saneamiento_ejec_storymap/MapServer";
const LAYER_SERIE = 17; // bd_geovivienda.ogei.tb_indicadores_serie

// Indicadores
const ID_X   = 'Ind_19';
const ID_Y   = 'Ind_18';
const ID_SZ  = 'Ind_12_pob';
const ID_COL = 'Ind_13';

// Años
const YEAR_START = 2011, YEAR_END = 2024;
/* NUEVO: año inicial de la animación (se mantiene) */
const START_YEAR = 2024;

const chart = echarts.init(document.getElementById('chart'));

/* ===================== Responsive helpers (NUEVO) ===================== */
/* Calcula métricas en función del tamaño del contenedor */
function responsiveMetrics(){
  const el = chart.getDom();
  const w = Math.max(320, el.clientWidth || 320);
  const h = Math.max(320, el.clientHeight || 320);

  const fw = Math.min(Math.max(w/1100, 0.70), 1.20); // escala por ancho
  const fh = Math.min(Math.max(h/650,  0.75), 1.25); // escala por alto

  // Fuentes
  const axisFont   = Math.round(11 * fw);
  const titleFont  = Math.round(16 * fw);
  const labelFont  = Math.round(13 * fw);
  const bigYear    = Math.round(32 * fw);

  // Márgenes (grid)
  const top    = Math.round((h < 500 ? 78 : 86) * fh);
  const bottom = Math.round((h < 500 ? 80 : 90) * fh);
  const left   = Math.round(40 * fw);
  const right  = Math.round((w < 900 ? 120 : 140) * fw); // deja espacio para timeline

  // Timeline (vertical, derecha)
  const tlWidth   = Math.round((w < 700 ? 42 : 55) * fw);
  const tlTop     = Math.round(20 * fh);
  const tlBottom  = Math.round(20 * fh);
  const tlItemGap = Math.round((w < 700 ? 6 : 10) * fh);
  const tlSymbol  = Math.round((w < 700 ? 6 : 8) * fw);

  // DataZoom sliders
  const dzH = Math.round((w < 700 ? 24 : 28) * fh);
  const dzW = Math.round((w < 700 ? 10 : 12) * fw);

  return {axisFont,titleFont,labelFont,bigYear,top,bottom,left,right,tlWidth,tlTop,tlBottom,tlItemGap,tlSymbol,dzH,dzW};
}

/* Aplica ajustes responsive sin cambiar la lógica */
function applyResponsiveTweaks(){
  const m = responsiveMetrics();
  const opt = chart.getOption();

  chart.setOption({
    title: (opt.title||[]).map((t,i)=> i===0 ? ({
      ...t, textStyle:{ ...(t.textStyle||{}), fontSize:m.titleFont }
    }) : t),

    grid: [{ ...(opt.grid?.[0]||{}), top:m.top, bottom:m.bottom, left:m.left, right:m.right, containLabel:true }],

    xAxis: [{ ...(opt.xAxis?.[0]||{}),
      nameTextStyle:{ fontSize:m.axisFont },
      axisLabel:{ ...(opt.xAxis?.[0]?.axisLabel||{}), fontSize:m.axisFont }
    }],
    yAxis: [{ ...(opt.yAxis?.[0]||{}),
      nameTextStyle:{ fontSize:m.axisFont },
      axisLabel:{ ...(opt.yAxis?.[0]?.axisLabel||{}), fontSize:m.axisFont }
    }],

    dataZoom: [
      { ...(opt.dataZoom?.[0]||{}), height:m.dzH, bottom:12 },
      { ...(opt.dataZoom?.[1]||{}) },
      { ...(opt.dataZoom?.[2]||{}), width:m.dzW, right:6 },
      { ...(opt.dataZoom?.[3]||{}) }
    ],

    timeline: [{
      ...(opt.timeline?.[0]||{}),
      width: m.tlWidth, right:0, top:m.tlTop, bottom:m.tlBottom,
      label: { ...(opt.timeline?.[0]?.label||{}), fontSize: Math.max(10, m.axisFont-1) },
      itemStyle: { ...(opt.timeline?.[0]?.itemStyle||{}), borderWidth: 1 },
      checkpointStyle: { ...(opt.timeline?.[0]?.checkpointStyle||{}), symbolSize: m.tlSymbol+4 },
      controlStyle: { ...(opt.timeline?.[0]?.controlStyle||{}), itemSize: m.tlSymbol+6 }
    }],

    // Ajusta font de labels de puntos y del rótulo de año si existen
    series: (opt.series||[]).map(s=>{
      if(s.name === 'yearLabel'){
        return { ...s, label: { ...(s.label||{}), fontSize: m.bigYear } };
      }
      if(s.type === 'scatter'){
        return { ...s, label: { ...(s.label||{}), fontSize: m.labelFont } };
      }
      return s;
    })
  }, false, true);
}

/* Observadores de tamaño */
window.addEventListener('resize', ()=>{
  chart.resize();
  applyResponsiveTweaks();
});
new ResizeObserver(()=>{
  chart.resize();
  applyResponsiveTweaks();
}).observe(chart.getDom());

/* ===================== Utils ===================== */
const norm = s => String(s ?? '').normalize('NFD').replace(/[\u0300-\u036f]/g,'').replace(/\s+/g,' ').trim().toUpperCase();
const toNum = v => {
  if (typeof v === 'number') return v;
  if (v == null) return NaN;
  let s = String(v).trim().replace(/\s/g,'').replace('%','');
  if (s.includes(',') && !s.includes('.')) s = s.replace(/,/g,'.');
  else if (s.includes(',') && s.includes('.')) s = s.replace(/,/g,'');
  const n = Number(s); return Number.isFinite(n) ? n : NaN;
};

/* Title Case ES */
const SMALL_WORDS = new Set(['de','del','la','las','el','los','y','e','o','u','al','da','do','das','dos']);
function toTitleCaseEs(str){
  const clean = String(str || '').replace(/\s+/g,' ').trim().toLowerCase();
  if(!clean) return '';
  const parts = clean.split(' ');
  return parts.map((w,i)=> (i>0 && SMALL_WORDS.has(w)) ? w : (w.charAt(0).toUpperCase() + w.slice(1))).join(' ');
}

/* Colores por continuidad */
function colorForContinuidad(h){
  const v = Number(h);
  if(!Number.isFinite(v)) return '#9e9e9e';
  if(v < 6)  return '#d00000';
  if(v < 12) return '#f40000';
  if(v < 18) return '#ffb20f';
  return '#1dfc12';
}
function qs(url, params){ return url + "?" + new URLSearchParams(params).toString(); }
function extent(arr){let m=+Infinity,M=-Infinity;for(const v of arr)if(Number.isFinite(v)){if(v<m)m=v;if(v>M)M=v}if(!Number.isFinite(m)||!Number.isFinite(M))return[0,1];if(m===M)return[0,M||1];return[m,M]}
function quantile(a,q){const s=a.slice().sort((x,y)=>x-y);if(!s.length)return NaN;const p=(s.length-1)*q,lo=Math.floor(p),hi=Math.ceil(p);return lo===hi?s[lo]:s[hi]+(s[hi]-s[lo])*(p-lo)}
function makeSizeFn(values, minPx=18, maxPx=85){
  const [mn,mx]=extent(values);
  return x=>{
    const v=Math.max(0,Number(x)||0);
    let t=(mx>mn)?(v-mn)/(mx-mn):0.5;
    t=Math.max(0,Math.min(1,t));
    return minPx + Math.sqrt(t)*(maxPx-minPx);
  }
}

/* ============ Fetch con paginación (ArcGIS) ============ */
async function fetchAllPaged(){
  const where = [
    "(id_indicador IN ('" + [ID_X, ID_Y, ID_SZ, ID_COL].join("','") + "'))",
    "(d_valores = 'CON ACCESO' OR id_indicador = '" + ID_COL + "')",
    `(anio >= ${YEAR_START} AND anio <= ${YEAR_END})`
  ].join(" AND ");

  let offset = 0, batch = 2000, all = [];
  while(true){
    const url = qs(`${SERVICE_BASE}/${LAYER_SERIE}/query`, {
      where,
      outFields: "id_indicador,anio,region,ambito,d_valores,valor_porcentaje,valor_recuento,flag_coef_var",
      returnGeometry: "false",
      orderByFields: "anio ASC, region ASC",
      resultOffset: offset,
      resultRecordCount: batch,
      f: "json"
    });
    const res = await fetch(url, {cache:'no-store'});
    if(!res.ok) throw new Error(`HTTP ${res.status} al consultar la tabla de serie`);
    const json = await res.json();
    if(json.error) throw new Error(json.error.message || 'Error del servicio');

    const feats = (json.features || []).map(f => f.attributes || {});
    all = all.concat(feats);

    if (!json.exceededTransferLimit && feats.length < batch) break;
    offset += feats.length;
    if (feats.length === 0) break;
  }
  // Excluir REGION = NACIONAL en cliente
  return all.filter(r => norm(r.region) !== 'NACIONAL');
}

/* ===================== Estado del filtro ===================== */
let currentAmbito = 'TOTAL';
let allRows = [];
let allRegions = [];
let selectedRegions = new Set();

function buildRegionIndex(rows){
  const set = new Set();
  for(const r of rows){
    const regN = norm(r.region);
    if(regN && regN !== 'NACIONAL') set.add(regN);
  }
  allRegions = [...set].sort().map(n=>({ norm:n, pretty:toTitleCaseEs(n) }));
  selectedRegions = new Set(allRegions.map(r=>r.norm)); // todas por defecto
  renderRegionDropdown();
}

function renderRegionDropdown(){
  const list = document.getElementById('regionList');
  list.innerHTML = '';
  for(const r of allRegions){
    const id = `chk_${r.norm.replace(/\s+/g,'_')}`;
    const row = document.createElement('label');
    row.className = 'dd-row';
    row.innerHTML = `
      <input type="checkbox" id="${id}" ${selectedRegions.has(r.norm)?'checked':''} data-region="${r.norm}">
      <span>${r.pretty}</span>
    `;
    list.appendChild(row);
  }
}

/* ============ Transformación por ÁMBITO + Filtros ============ */
function buildBy(rows, ambitoWanted){
  const amb = norm(ambitoWanted); // TOTAL | URBANO | RURAL
  let data = rows.filter(r => norm(r.ambito) === amb);

  // En RURAL se excluye CALLAO
  if(amb === 'RURAL'){
    data = data.filter(r => norm(r.region) !== 'CALLAO');
  }

  // Filtro por departamentos seleccionados
  data = data.filter(r => selectedRegions.has(norm(r.region)));

  const byYR = new Map(); // `${anio}|${region}`
  for(const r of data){
    const key = `${r.anio}|${r.region}`;
    if(!byYR.has(key)) byYR.set(key, { anio:r.anio, region:r.region, ambito:r.ambito });
    const obj = byYR.get(key);
    const id = String(r.id_indicador);
    if(id === ID_X){    obj.x_pct   = toNum(r.valor_porcentaje); obj.flagX = r.flag_coef_var; }
    if(id === ID_Y){    obj.y_pct   = toNum(r.valor_porcentaje); obj.flagY = r.flag_coef_var; }
    if(id === ID_SZ){   obj.sizePct = toNum(r.valor_porcentaje); obj.flagS = r.flag_coef_var; }
    if(id === ID_COL){  obj.contH   = toNum(r.valor_recuento);   obj.flagC = r.flag_coef_var; }
  }

  const yearsSet = new Set(), byYear = new Map();
  for(const v of byYR.values()){
    const y = Number(v.anio); if(!Number.isFinite(y)) continue;
    if(!byYear.has(y)) byYear.set(y, []);
    byYear.get(y).push(v);
    yearsSet.add(y);
  }
  return { years:[...yearsSet].sort((a,b)=>a-b), byYear };
}

/* ============ Construcción de opciones ECharts (con tamaños responsive) ============ */
function buildOptionsStruct(byYear){
  const allX=[], allY=[], allS=[];
  for(const arr of byYear.values()){
    for(const p of arr){
      if(Number.isFinite(p.x_pct)) allX.push(p.x_pct);
      if(Number.isFinite(p.y_pct)) allY.push(p.y_pct);
      if(Number.isFinite(p.sizePct)) allS.push(p.sizePct);
    }
  }
  if(!allX.length || !allY.length) throw new Error('No hay datos válidos para X o Y en el ámbito/filtros seleccionados.');

  const xQ05=quantile(allX,0.05), xQ95=quantile(allX,0.95);
  const yQ05=quantile(allY,0.05), yQ95=quantile(allY,0.95);
  const xPad=(xQ95-xQ05)*0.05, yPad=(yQ95-yQ05)*0.05;
  const [xMinAll,xMaxAll]=extent(allX), [yMinAll,yMaxAll]=extent(allY);
  const clamp01 = v => Math.max(0, Math.min(100, v));
  const xInitMin = clamp01(Math.min(xQ05 - xPad, xMinAll));
  const xInitMax = clamp01(Math.max(xQ95 + xPad, xMaxAll));
  const yInitMin = clamp01(Math.min(yQ05 - yPad, yMinAll));
  const yInitMax = clamp01(Math.max(yQ95 + yPad, yMaxAll));

  // Métricas responsive para fuentes y grid
  const m = responsiveMetrics();

  // Posición rótulo de año (se basa en rango inicial)
  const yearX = xInitMin + 0.85 * (xInitMax - xInitMin);
  const yearY = yInitMin;

  const sizeFn = makeSizeFn(allS, 18, 85);

  const options=[], years=[...byYear.keys()].sort((a,b)=>a-b);
  for(const y of years){
    const pts = (byYear.get(y) || []).map(p => {
      if(!Number.isFinite(p.x_pct) || !Number.isFinite(p.y_pct)) return null;
      const regionPretty = toTitleCaseEs(p.region);
      const ambPretty = toTitleCaseEs(p.ambito);

      return {
        // value: [x, y, size, region, ambito, contH, flagX, flagY, flagS, flagC]
        value: [p.x_pct, p.y_pct, p.sizePct, regionPretty, ambPretty, p.contH, p.flagX || '', p.flagY || '', p.flagS || '', p.flagC || ''],
        itemStyle:{
          color: colorForContinuidad(p.contH),
          opacity: DOT_BORDER.opacity,
          borderColor: DOT_BORDER.color,
          borderWidth: DOT_BORDER.width,
          borderType: DOT_BORDER.type
        },
        emphasis:{
          itemStyle:{
            borderColor: DOT_BORDER.color,
            borderWidth: Math.max(DOT_BORDER.width + 0.5, DOT_BORDER.width),
            borderType: DOT_BORDER.type
          },
          scale:1.08, focus:'self'
        }
      };
    }).filter(Boolean);

    options.push({
      series:[
        {
          name:String(y),
          type:'scatter',
          data:pts,
          symbolSize:(val)=>sizeFn(val[2]),
          label:{
            show:true,
            formatter:(p)=>p.value[3],
            position:'right', fontSize:m.labelFont, color:'#333'
          }
        },
        {
          name:'yearLabel',
          type:'scatter',
          data:[[yearX, yearY]],
          symbolSize:0,
          silent:true,
          tooltip:{show:false},
          z:0,
          label:{
            show:true,
            formatter: String(y),
            position:'top',
            distance:12,
            color:'#e5e7eb',
            fontSize:m.bigYear,
            fontWeight:700
          }
        }
      ]
    });
  }

  const startIdx = Math.max(0, years.indexOf(START_YEAR));

  return {
    baseOption:{
      timeline:{
        axisType:'category', orient:'vertical', autoPlay:true, inverse:true,
        playInterval:2000, right:0, top:m.tlTop, bottom:m.tlBottom, width:m.tlWidth, symbol:'none',
        checkpointStyle:{ borderWidth:2 }, controlStyle:{ showNextBtn:false, showPrevBtn:false },
        label:{ fontSize: Math.max(10, m.axisFont-1) },
        data: years,
        currentIndex: startIdx
      },
      title:[
        { text:'Evolución de Principales Indicadores de Saneamiento',
          left:'center', top:8, textStyle:{ fontWeight:'700', fontSize:m.titleFont } }
      ],
      tooltip:{
        padding:6, borderWidth:1,
        formatter:(o)=>{
          const [xVal,yVal,pctCl,regionPretty,ambPretty,contH,flagX,flagY,flagS,flagC] = o.value;
          const fmtPct = (v, flag) => {
            const base = Number.isFinite(v) ? new Intl.NumberFormat('es-PE',{ maximumFractionDigits:2 }).format(v)+'%' : '—';
            return flag ? base + String(flag) : base;
          };
          const fmtHrs = (v, flag) => {
            const base = Number.isFinite(v) ? new Intl.NumberFormat('es-PE',{ maximumFractionDigits:1 }).format(v)+' h' : '—';
            return flag ? base + String(flag) : base;
          };
          const yTxt = fmtPct(yVal, flagY);
          const xTxt = fmtPct(xVal, flagX);
          const sTxt = fmtPct(pctCl, flagS);
          const cTxt = fmtHrs(contH, flagC);
          return `<b>${regionPretty}</b> (${ambPretty})<br>
                  Acceso a agua (Y): <b>${yTxt}</b><br>
                  Acceso a Alcantarillado/DSE: <b>${xTxt}</b><br>
                  Continuidad (color): <b>${cTxt}</b><br>
                  % Pob. con Cl aceptable (tamaño): <b>${sTxt}</b>`;
        }
      },
      grid:{ top:m.top, left:m.left, right:m.right, bottom:m.bottom, containLabel:true },
      xAxis:{ type:'value', name:'Acceso a Alcantarillado/DSE (%)',
        min:xInitMin, max:xInitMax, nameGap:25, nameLocation:'middle',
        nameTextStyle:{ fontSize:m.axisFont }, splitLine:{ show:true }, scale:true,
        axisLabel:{ fontSize:m.axisFont, formatter:(v)=>`${new Intl.NumberFormat('es-PE',{ maximumFractionDigits:0 }).format(v)}%` } },
      yAxis:{ type:'value', name:'Acceso a agua (%)',
        min:yInitMin, max:yInitMax, nameTextStyle:{ fontSize:m.axisFont }, splitLine:{ show:true }, scale:true,
        axisLabel:{ fontSize:m.axisFont, formatter:(v)=>`${new Intl.NumberFormat('es-PE',{ maximumFractionDigits:0 }).format(v)}%` } },
      dataZoom:[
        { type:'slider', xAxisIndex:0, filterMode:'none', bottom:12, height:m.dzH },
        { type:'inside', xAxisIndex:0, filterMode:'none' },
        { type:'slider', yAxisIndex:0, filterMode:'none', right:6, width:m.dzW },
        { type:'inside', yAxisIndex:0, filterMode:'none' }
      ],
      series:[{ type:'scatter', data:[] }],
      animationDurationUpdate:1000,
      animationEasingUpdate:'quinticInOut'
    },
    options
  };
}

/* ===================== Run ===================== */
(async function run(){
  try{
    chart.showLoading({ text: 'Cargando datos…' });
    allRows = await fetchAllPaged();
    buildRegionIndex(allRows);

    async function render(){
      const { years, byYear } = buildBy(allRows, currentAmbito);
      if (!years.length) throw new Error('No hay datos para el ámbito/filtros seleccionados.');
      const option = buildOptionsStruct(byYear);
      chart.hideLoading();
      chart.setOption(option, true);
      applyResponsiveTweaks(); // aplicar inmediatamente tras render
    }

    // Segmentación
    document.querySelectorAll('.seg-btn').forEach(btn=>{
      btn.addEventListener('click', async ()=>{
        document.querySelectorAll('.seg-btn').forEach(b=>b.classList.remove('active'));
        btn.classList.add('active');
        currentAmbito = btn.getAttribute('data-ambito') || 'TOTAL';
        chart.showLoading({ text: 'Actualizando…' });
        await render();
      });
    });

    // Desplegable departamentos
    const dd = document.getElementById('regionDD');
    const trigger = document.getElementById('regionTrigger');
    const panel = document.getElementById('regionPanel');
    const listEl = document.getElementById('regionList');
    const searchEl = document.getElementById('regionSearch');
    const selAllBtn = document.getElementById('selAll');
    const selNoneBtn = document.getElementById('selNone');

    function closeOnOutside(e){
      if(!dd.contains(e.target)) dd.classList.remove('open');
    }
    trigger.addEventListener('click', ()=>{
      dd.classList.toggle('open');
      if(dd.classList.contains('open')) document.addEventListener('click', closeOnOutside, { once:true });
    });

    // Buscar
    searchEl.addEventListener('input', ()=>{
      const q = searchEl.value.trim().toLowerCase();
      for(const row of listEl.querySelectorAll('.dd-row')){
        const txt = row.textContent.trim().toLowerCase();
        row.style.display = txt.includes(q) ? '' : 'none';
      }
    });

    // Select all / none
    selAllBtn.addEventListener('click', async ()=>{
      selectedRegions = new Set(allRegions.map(r=>r.norm));
      renderRegionDropdown();
      chart.showLoading({ text: 'Actualizando…' });
      await render();
    });
    selNoneBtn.addEventListener('click', async ()=>{
      selectedRegions = new Set();
      renderRegionDropdown();
      chart.showLoading({ text: 'Actualizando…' });
      await render();
    });

    // Cambios en checks
    listEl.addEventListener('change', async (e)=>{
      const t = e.target;
      if(t && t.matches('input[type="checkbox"][data-region]')){
        const reg = t.getAttribute('data-region');
        if(t.checked) selectedRegions.add(reg); else selectedRegions.delete(reg);
        chart.showLoading({ text: 'Actualizando…' });
        await render();
      }
    });

    // Primer render
    await render();

  }catch(err){
    console.error(err);
    chart.hideLoading();
    chart.setOption({
      title:{ text:'Error al cargar datos', left:'center' },
      graphic:{ type:'text', left:'center', top:'middle',
        style:{ text: (err&&err.message)? err.message : 'Fallo de carga.', fontSize:14 } }
    });
  }
})();
</script>
</body>
</html>
