<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Porcentaje de hogares con presencia de cloro residual libre mayor o igual a 0.5 mg/L, por ámbito </title>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
  <style>
    :root{ --bg:#ffffff; --fg:#111827; --muted:#6b7280; --card:#fafafa; --shadow:0 6px 28px rgba(0,0,0,.08); }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    #wrap{max-width:1100px;margin:18px auto;padding:0 14px}
    h1{font-weight:700;font-size:20px;margin:0 0 6px;text-align:center}
    .sub{color:var(--muted);font-size:12px;margin:0 0 14px;text-align:center}
    #chart{height:70vh;min-height:460px;background:var(--card);border-radius:16px;box-shadow:var(--shadow);position:relative}
    #loading{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:13px;color:#6b7280}
    #err{margin-top:10px;color:#b91c1c;font-size:12px;white-space:pre-wrap;display:none}
  </style>
</head>
<body>
<div id="wrap">
  <h1>Porcentaje de hogares con presencia de cloro residual libre mayor o igual a 0.5 mg/L, por ámbito </h1>
  <p class="sub">Fuente: ENAHO</p>
  <div id="chart"><div id="loading">Cargando datos…</div></div>
  <div id="err"></div>
</div>

<script>
(function(){
  const SERVICE = "https://pportalgis.vivienda.gob.pe/phtserver/rest/services/Hosted/Mapa_coropletico_2/FeatureServer";
  const TARGET_TABLE_NAME = "bd_geovivienda.ogei.tb_indicadores_serie";
  const nf1 = new Intl.NumberFormat('es-PE', { minimumFractionDigits: 1, maximumFractionDigits: 1 });

  const BASE_HEX = "#2F4858";
  function hexToHsl(hex){
    const m = hex.replace('#','');
    const r=parseInt(m.slice(0,2),16)/255, g=parseInt(m.slice(2,4),16)/255, b=parseInt(m.slice(4,6),16)/255;
    const max=Math.max(r,g,b), min=Math.min(r,g,b); let h,s,l=(max+min)/2;
    if(max===min){h=s=0;} else {const d=max-min; s=l>0.5? d/(2-max-min) : d/(max+min);
      switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;} h/=6;}
    return {h:Math.round(h*360), s:Math.round(s*100), l:Math.round(l*100)};
  }
  function hsl(h,s,l,a=1){ return `hsla(${h} ${s}% ${l}% / ${a})`; }
  function norm(txt){ return String(txt||'').normalize('NFD').replace(/\p{Diacritic}/gu,'').trim().toLowerCase(); }

  const chart = echarts.init(document.getElementById('chart'));
  window.addEventListener('resize', ()=>chart.resize());
  chart.setOption({
    backgroundColor: '#ffffff',
    grid: { left: 96, right: 48, top: 74, bottom: 72, containLabel: true },
    legend: { top: 14, left: 'center', itemWidth: 22, itemHeight: 10, icon: 'roundRect', textStyle: { fontSize: 12 } },
    tooltip: {
      trigger: 'axis',
      axisPointer: { type: 'line' },
      formatter: (params)=>{
        const year = params?.[0]?.axisValue ?? '';
        const lines = [`<b>${year}</b>`];
        (params||[]).forEach(p=>{
          const v = (p.value==null||isNaN(p.value)) ? '—' : `${nf1.format(+p.value)}%`;
          lines.push(`${p.marker} ${p.seriesName}: <b>${v}</b>`);
        });
        return lines.join('<br/>');
      }
    },
    xAxis: {
      type:'category',
      boundaryGap: true,
      name:'Años',
      nameLocation:'middle',
      nameGap:34,
      axisTick:{alignWithLabel:true},
      axisLabel:{ margin: 14 },
      animation:false,
      data:[]
    },
    yAxis: {
      type:'value',
      name:'%',
      axisLabel:{ formatter:v=>nf1.format(v), margin: 12 },
      splitLine:{show:true},
      scale:true
    },
    animation: true,
    animationDuration: 4000,
    animationDurationUpdate: 4000,
    series: []
  });

  (async function run(){
    try{
      const meta = await jsonp(SERVICE, { f: "pjson" });
      const tables = (meta.data && meta.data.tables) || [];
      const layers = (meta.data && meta.data.layers) || [];
      const all = [...tables, ...layers];
      const targetLower = TARGET_TABLE_NAME.toLowerCase();
      let found = all.find(t => t && t.name && String(t.name).toLowerCase().includes(targetLower))
                 || all.find(t => t && t.name && String(t.name).toLowerCase().includes("tb_indicadores_serie"));
      if (!found) throw new Error("No se encontró la tabla objetivo en el servicio.");

      const tableUrl = SERVICE + "/" + found.id;
      const layerInfo = await jsonp(tableUrl, { f: "pjson" });
      const f_anio   = resolveFieldName(layerInfo.data, ["anio"]);
      const f_ambito = resolveFieldName(layerInfo.data, ["ambito"]);
      const f_val    = resolveFieldName(layerInfo.data, ["valor_porcentaje","valor porcentaje","valor_porcentual"]);
      const f_region = resolveFieldName(layerInfo.data, ["region"]);
      const f_ind    = resolveFieldName(layerInfo.data, ["id_indicador","indicador_id"]);
      const f_dvals  = resolveFieldName(layerInfo.data, ["d_valores","d valores","descripcion_valor"]);
      if(!(f_anio && f_ambito && f_val && f_region && f_ind && f_dvals)) throw new Error("Campos requeridos no hallados.");

      const baseHSL = hexToHsl(BASE_HEX);

      // === Query (id_indicador = 'Ind_12_2') ===
      const WHERE = `(${f_region} = 'NACIONAL') AND (${f_ind} = 'Ind_12_2') AND (${f_dvals} = 'CON ACCESO')`;
      const res = await jsonp(tableUrl + "/query", {
        where: WHERE,
        outFields: [f_anio,f_ambito,f_val].join(","),
        orderByFields: `${f_anio} ASC, ${f_ambito} ASC`,
        returnGeometry: "false",
        f: "json"
      });
      const features = (res.data && res.data.features) || [];
      if(!features.length) throw new Error("La consulta no devolvió filas.");

      const raw = features.map(f=>f.attributes)
        .filter(r => r && r[f_anio] != null && r[f_ambito] != null && r[f_val] != null)
        .map(r => ({ anio: Number(r[f_anio]), ambito: String(r[f_ambito]), valor: Number(r[f_val]) }));

      // Escala a %
      const maxRaw = Math.max(...raw.map(r=>r.valor));
      const scale = (maxRaw <= 1.5) ? 100 : 1;
      raw.forEach(r => r.valor = r.valor * scale);

      // Promedio por año/ámbito
      const agg = new Map();
      raw.forEach(r=>{
        const key = r.ambito + "|" + r.anio;
        const cur = agg.get(key) || { sum:0, count:0 };
        cur.sum += r.valor; cur.count += 1;
        agg.set(key, cur);
      });
      const rows = Array.from(agg.entries()).map(([key, o])=>{
        const [ambito, anio] = key.split("|");
        return { ambito, anio: Number(anio), valor: o.sum / o.count };
      });

      const years = Array.from(new Set(rows.map(r=>r.anio))).sort((a,b)=>a-b).map(String);
      const byAmb = {};
      rows.forEach(r => { (byAmb[r.ambito] ||= []).push(r); });

      const seriesPrep = [];
      Object.entries(byAmb).forEach(([ambito, arr])=>{
        const m = new Map(arr.map(o=>[String(o.anio), o.valor]));
        const data = years.map(y => (m.has(y) ? Number(m.get(y)) : null));
        const valid = data.filter(v=>v!=null);
        const mean = valid.length ? valid.reduce((a,b)=>a+b,0)/valid.length : 0;
        seriesPrep.push({ name: ambito, data, mean });
      });

      // Orden y color
      seriesPrep.sort((a,b)=> (b.mean||0)-(a.mean||0));
      const n = Math.max(1, seriesPrep.length);
      const minL = Math.max(18, baseHSL.l - 12);
      const maxL = Math.min(85, baseHSL.l + 26);
      const stepL = (i)=> Math.round(minL + (maxL - minL) * (i/(n-1 || 1)));

      // helper para decidir qué puntos etiquetar (cada 2 años + último)
      const showEvery = 2;

      const series = seriesPrep.map((s,i)=>{
        const col = hsl(baseHSL.h, baseHSL.s, stepL(i));
        const nameN = norm(s.name);
        const lineType =
          nameN === 'nacional' ? 'solid' :
          nameN === 'urbano'   ? 'dashed' :
          nameN === 'rural'    ? 'dotted' : 'solid';

        // Construir data con etiqueta sólo en puntos seleccionados
        const data = s.data.map((v, idx) => {
          const showLab = (idx % showEvery === 0) || (idx === s.data.length - 1);
          return (v == null) ? null : { value: v, label: { show: showLab } };
        });

        return {
          name: s.name,
          type: 'line',
          smooth: 0.25,
          showSymbol: true,
          symbol: 'circle',
          symbolSize: 6,
          lineStyle: { width: 2, color: col, type: lineType, cap: 'round', join: 'round' },
          itemStyle: { color: col },
          emphasis: { focus: 'series', scale: false },
          clip: true,
          data,
          label:{
            position:'top',
            distance:10,
            fontSize:12,
            color:'#111827',
            formatter:(p)=> (p.value==null||isNaN(p.value)) ? '' : `${nf1.format(+p.value)}%`
          },
          labelLayout: (params)=>{
            // anti-solape vertical + micro-offset alternado por punto
            const out = { moveOverlap: 'shiftY', hideOverlap: false };
            const alt = (params.dataIndex % 2 === 0) ? -4 : 4;
            if (params && params.label) params.label.y += alt;
            return out;
          }
        };
      });

      // Eje Y: 0% a 105% con colchón
      const vals = seriesPrep.flatMap(s=>s.data).filter(v=>v!=null && isFinite(v));
      const vmin = Math.min(...vals), vmax = Math.max(...vals);
      const pad = Math.max((vmax - vmin) * 0.18, 1.5);
      const yMin = Math.max(0, Math.floor((vmin - pad) * 10)/10);
      const yMax = Math.min(105, Math.ceil ((vmax + pad) * 10)/10);

      // Leyenda ordenada
      const prefer = ["NACIONAL","URBANO","RURAL"];
      const names = series.map(s=>s.name);
      const legendData = [];
      prefer.forEach(lbl=>{ const hit = names.find(n => norm(n)===norm(lbl)); if(hit) legendData.push(hit); });
      names.forEach(n=>{ if(!legendData.includes(n)) legendData.push(n); });

      chart.setOption({
        xAxis: { data: years },
        yAxis: { min: yMin, max: yMax },
        legend: { data: legendData },
        series
      });

      document.getElementById('loading').style.display = 'none';
      const $err = document.getElementById('err'); $err.style.display = 'none'; $err.textContent = '';

    }catch(e){
      document.getElementById('loading').style.display = 'none';
      const $err = document.getElementById('err');
      $err.style.display = 'block';
      $err.textContent = "Error: " + (e && e.message ? e.message : e);
      console.error(e);
    }
  })();

  // Utilidades JSONP / fields
  function jsonp(url, params, timeoutMs=15000){
    return new Promise((resolve, reject)=>{
      const cb = "__arcgis_cb_" + Math.random().toString(36).slice(2);
      params = { ...(params||{}), callback: cb };
      const u = url + "?" + new URLSearchParams(params).toString();
      const s = document.createElement('script');
      let timer = setTimeout(()=>{ cleanup(); reject(new Error("Timeout JSONP")); }, timeoutMs);
      function cleanup(){ clearTimeout(timer); if (s.parentNode) s.parentNode.removeChild(s); try{ delete window[cb]; }catch(_){ } }
      window[cb] = (data)=>{ cleanup(); resolve({data, url:u}); };
      s.src = u; s.onerror = ()=>{ cleanup(); reject(new Error("Error de script JSONP")); };
      document.head.appendChild(s);
    });
  }
  function resolveFieldName(layerMeta, candidates){
    const fields = (layerMeta && layerMeta.fields) || [];
    const wanted = candidates.map(s => String(s).toLowerCase());
    for(const f of fields){
      const n = (f.name||"").toLowerCase();
      const a = (f.alias||"").toLowerCase();
      if (wanted.includes(n) || (a && wanted.includes(a))) return f.name;
    }
    return null;
  }
})();
</script>
</body>
</html>
