<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Porcentaje de población en hogares con presencia de cloro residual libre ≥ 0.5 mg/L, por ámbito</title>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
  <style>
    :root{ --bg:#ffffff; --fg:#111827; --muted:#6b7280; --card:#fafafa; --shadow:0 6px 28px rgba(0,0,0,.08); }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}

    #wrap{max-width:1200px;margin:16px auto;padding:0 12px}
    @media (max-width: 900px){ #wrap{max-width:100%; padding:0 8px} }
    h1{font-weight:700;font-size:clamp(16px,2.2vw,22px);margin:0 0 6px;text-align:center;line-height:1.2}
    .sub{color:var(--muted);font-size:clamp(11px,1.6vw,13px);margin:0 0 12px;text-align:center}

    .chart-shell{
      background:var(--card); border-radius:16px; box-shadow:var(--shadow);
      width:100%; height:100%; min-height:360px; position:relative; overflow:hidden;
    }
    .chart-shell[data-autoheight="1"]{ aspect-ratio:16/9; min-height:420px; }

    /* Embebido StoryMaps/Sidecar: alto controlado y sin scroll */
    body.embed.storymaps .chart-shell{ height: clamp(560px, 72vh, 920px) !important; min-height: 560px; }
    body.embed.storymaps .chart-shell[data-autoheight]{ aspect-ratio:auto; }

    /* Embebido genérico (otros iframes) */
    body.embed.generic, body.embed.generic html{ overflow:hidden; }

    #chart{position:absolute; inset:0}
    #loading{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:13px;color:#6b7280}
    #err{margin-top:10px;color:#b91c1c;font-size:12px;white-space:pre-wrap;display:none}
  </style>
</head>
<body>
<div id="wrap">
  <h1>Porcentaje de población en hogares con presencia de cloro residual libre ≥ 0.5 mg/L, por ámbito</h1>
  <p class="sub">Fuente: ENAPRES</p>

  <div id="chartShell" class="chart-shell" data-autoheight="0">
    <div id="chart"></div>
    <div id="loading">Cargando datos…</div>
  </div>

  <div id="err"></div>
</div>

<script>
(function(){
  /* ====== EMBED / StoryMaps ====== */
  const EMBED = (()=>{ try{ return window.self !== window.top; }catch(_){ return true; } })();
  const REF = (document.referrer||"") + " " + (window.location.ancestorOrigins ? Array.from(window.location.ancestorOrigins).join(" ") : "");
  const IS_STORYMAP = /storymaps|arcgis\.com/i.test(REF);
  if (EMBED){
    document.body.classList.add('embed');
    document.body.classList.add(IS_STORYMAP ? 'storymaps' : 'generic');
  }
  const shell = document.getElementById('chartShell');
  function applyGenericEmbedHeight(){
    if(!(EMBED && !IS_STORYMAP)) return;
    shell.setAttribute('data-autoheight','0');
    const setH = ()=>{
      const vh = Math.max(window.innerHeight || 0, 420);
      const h = Math.max(420, Math.min(Math.floor(vh*0.88), 880));
      shell.style.height = h + 'px';
      shell.style.minHeight = h + 'px';
    };
    setH();
    window.addEventListener('resize', setH);
  }
  applyGenericEmbedHeight();

  // ======= Config =======
  const SERVICE = "https://pportalgis.vivienda.gob.pe/phtserver/rest/services/indicadores_saneamiento_ejec_storymap/MapServer";
  const TARGET_TABLE_NAME = "bd_geovivienda.ogei.tb_indicadores_serie";
  const INDICADOR_OBJ = "Ind_12_pob";
  const D_VALORES = "CON ACCESO";
  const REGION_TOTAL = "NACIONAL";

  // ======= Helpers =======
  const nf1 = new Intl.NumberFormat('es-PE', { minimumFractionDigits: 1, maximumFractionDigits: 1 });
  const norm = (s)=> String(s||'').replace(/\s+/g,' ').trim();
  const up   = (s)=> norm(s).toUpperCase();
  const cleanFlag = (v)=> { const t = String(v==null?'':v).trim(); return t ? t : ''; };

  // Formateo de valor_recuento (valores en **miles**)
  function formatRecuento(vThousands){
    if(vThousands == null || isNaN(vThousands)) return '';
    const n = Number(vThousands), sign = n < 0 ? '-' : '';
    const absT = Math.abs(n);
    if (absT >= 1000) {
      const millions = absT / 1000;
      return `${sign}${millions.toLocaleString('es-PE',{minimumFractionDigits:1,maximumFractionDigits:1})} millones`;
    } else {
      return `${sign}${absT.toLocaleString('es-PE',{minimumFractionDigits:1,maximumFractionDigits:1})} mil`;
    }
  }

  const $err = document.getElementById('err');
  const $loading = document.getElementById('loading');

  const qs = (u,p)=> u+"?"+new URLSearchParams(p).toString();
  function jsonp(url, params, timeoutMs=20000){
    return new Promise((resolve, reject)=>{
      const cb="__arcgis_cb_"+Math.random().toString(36).slice(2);
      params={...(params||{}), callback:cb};
      const u=qs(url,params); const s=document.createElement('script'); let settled=false;
      const timer=setTimeout(()=>{ if(settled) return; settled=true; cleanup(); reject(new Error("Timeout JSONP: "+u)); }, timeoutMs);
      function cleanup(){ clearTimeout(timer); if(s.parentNode) s.parentNode.removeChild(s); try{ delete window[cb]; }catch(_){ } }
      window[cb]=(data)=>{ if(settled) return; settled=true; cleanup(); resolve({data,url:u}); };
      s.src=u;
      s.onerror=()=>{ if(settled) return; settled=true; cleanup(); reject(new Error("Error de script JSONP: "+u)); };
      document.head.appendChild(s);
    });
  }
  function resolveFieldName(meta, candidates){
    const fields=(meta&&meta.fields)||[], wanted=candidates.map(x=>String(x).toLowerCase());
    for(const f of fields){
      const n=(f.name||"").toLowerCase(), a=(f.alias||"").toLowerCase();
      if(wanted.includes(n) || (a&&wanted.includes(a))) return f.name;
    }
    return null;
  }

  // ====== Colores ======
  const BASE_HEX = "#2F4858";
  function hexToHsl(hex){
    const m=hex.replace('#','');
    const r=parseInt(m.slice(0,2),16)/255, g=parseInt(m.slice(2,4),16)/255, b=parseInt(m.slice(4,6),16)/255;
    const max=Math.max(r,g,b), min=Math.min(r,g,b); let h,s,l=(max+min)/2;
    if(max===min){h=s=0;} else {const d=max-min; s=l>0.5? d/(2-max-min) : d/(max+min);
      switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;} h/=6;}
    return {h:Math.round(h*360), s:Math.round(s*100), l:Math.round(l*100)};
  }
  const baseHSL = hexToHsl(BASE_HEX);
  const hsl = (h,s,l,a=1)=>`hsla(${h} ${s}% ${l}% / ${a})`;

  // ====== Leyenda: porción de línea (SVG) ======
  function makeLegendLineIcon(color, lineType){
    const dash = lineType==='dashed' ? '8,6' : (lineType==='dotted' ? '2,6' : '');
    try{
      const svg =
        `<svg xmlns="http://www.w3.org/2000/svg" width="44" height="12" viewBox="0 0 44 12">
           <path d="M3 6 H41" fill="none" stroke="${color}" stroke-width="3" stroke-linecap="round"
                 ${dash ? `stroke-dasharray="${dash}"` : ''}/>
         </svg>`;
      return 'image://data:image/svg+xml;utf8,' + encodeURIComponent(svg);
    }catch(_){ return 'roundRect'; }
  }

  // ====== Responsive metrics ======
  function responsiveMetrics(){
    const w=Math.max(320, shell.clientWidth||320);
    const h=Math.max(300, shell.clientHeight||300);
    const f = Math.min(Math.max(w/900, 0.7), 1.25);
    const fh= Math.min(Math.max(h/600, 0.75), 1.25);

    const legendFont=Math.round(12*f);
    const axisFont=Math.round(11*f);
    const labelFont=Math.round(10*f);

    const top = Math.round(h<420? 54*fh : 62*fh);
    const bottom = Math.round(h<420? 58*fh : 74*fh);
    const left = Math.round(Math.min(110, 92*f));
    const right= Math.round(Math.min(60, 42*f));

    const legendMaxWidth=Math.round(w*0.92);

    return {legendFont,axisFont,labelFont,top,bottom,left,right,legendMaxWidth};
  }

  // ====== ECharts base ======
  const chart = echarts.init(document.getElementById('chart'));
  window.addEventListener('resize', onResize);
  new ResizeObserver(onResize).observe(shell);

  function baseOptionFactory(){
    const m=responsiveMetrics();
    return {
      backgroundColor:'#ffffff',
      grid:{ left:m.left, right:m.right, top:m.top, bottom:m.bottom, containLabel:true },
      legend:{ type:'scroll', top:10, left:'center',
               itemWidth:44, itemHeight:12, icon:'roundRect',
               textStyle:{ fontSize:m.legendFont }, width:m.legendMaxWidth },
      tooltip:{
        trigger:'axis', axisPointer:{ type:'line' }, confine:true, appendToBody:true,
        formatter:(params)=>{
          const opt = chart.getOption();
          const year = params?.[0]?.axisValue ?? '';
          const lines = [`<b>${year}</b>`];
          (params||[]).forEach(p=>{
            const serOpt = opt.series[p.seriesIndex] || {};
            const recMap  = serOpt._recByYear  || {};
            const flagMap = serOpt._flagByYear || {};
            const flagSuf = flagMap[String(year)] ? String(flagMap[String(year)]) : '';
            const vTxt = (p.value==null||isNaN(p.value)) ? '—' : `${nf1.format(+p.value)}%${flagSuf}`;
            const rec = recMap[String(year)];
            const recTxt = (rec==null || isNaN(rec)) ? '' : ` - ${formatRecuento(rec)}${flagSuf}`;
            lines.push(`${p.marker} ${p.seriesName}: <b>${vTxt}</b>${recTxt}`);
          });
          return lines.join('<br/>');
        }
      },
      xAxis:{ type:'category', boundaryGap:true, name:'Años', nameLocation:'middle', nameGap:34,
              axisTick:{alignWithLabel:true}, axisLabel:{ margin:14, fontSize:m.axisFont }, animation:false, data:[] },
      yAxis:{ type:'value', name:'%Pob. con Cl aceptable',
              nameTextStyle:{fontSize:m.axisFont},
              axisLabel:{ formatter:v=>nf1.format(v), margin:12, fontSize:m.axisFont },
              splitLine:{show:true}, scale:true },
      animation:true,
      animationDuration:1200,            /* ← Mantenemos tu animación original */
      animationDurationUpdate:1200,
      series:[],
      graphic:[]
    };
  }

  function onResize(){
    const opt=chart.getOption(); const m=responsiveMetrics(); chart.resize();
    chart.setOption({
      grid:{ left:m.left, right:m.right, top:m.top, bottom:m.bottom, containLabel:true },
      legend:{ textStyle:{ fontSize:m.legendFont }, top:10, left:'center', width:m.legendMaxWidth },
      xAxis:[{ ...(opt.xAxis?.[0]||{}), axisLabel:{ ...(opt.xAxis?.[0]?.axisLabel||{}), fontSize:m.axisFont } }],
      yAxis:[{ ...(opt.yAxis?.[0]||{}), nameTextStyle:{fontSize:m.axisFont}, axisLabel:{ ...(opt.yAxis?.[0]?.axisLabel||{}), fontSize:m.axisFont } }]
    });
  }

  // Flecha volver
  function backGraphic(color, onClick){
    const size=Math.round(20*Math.min(Math.max(shell.clientWidth/900,0.7),1.25));
    const cx=size, cy=size, r=size;
    return [{
      type:'group', left:10, top:10, z:100, bounding:'all', cursor:'pointer', onclick:onClick,
      children:[
        {type:'circle', shape:{cx,cy,r}, style:{fill:'#fff', stroke:color||'#111827', lineWidth:2, shadowBlur:6, shadowColor:'rgba(0,0,0,.08)'}},
        {type:'polyline', shape:{points:[[cx+4,cy-8],[cx-8,cy],[cx+4,cy+8]]}, style:{stroke:color||'#111827', lineWidth:3, lineCap:'round', lineJoin:'round'}}
      ]
    }];
  }

  // ======= Estado / metadatos =======
  let tableUrl = null;
  let fields = {};
  async function initMeta(){
    const meta = await jsonp(SERVICE, { f: "pjson" });
    const all = [...(meta.data.tables||[]), ...(meta.data.layers||[])];
    const found =
      all.find(t => t && t.name && up(t.name).includes(up(TARGET_TABLE_NAME))) ||
      all.find(t => t && t.name && up(t.name).includes("TB_INDICADORES_SERIE"));
    if (!found) throw new Error("No se encontró la tabla objetivo en el servicio.");
    tableUrl = SERVICE + "/" + found.id;

    const info = await jsonp(tableUrl, { f:"pjson" });
    fields = {
      anio  : resolveFieldName(info.data, ["anio"]),
      ambito: resolveFieldName(info.data, ["ambito"]),
      valor : resolveFieldName(info.data, ["valor_porcentaje","valor porcentaje","valor_porcentual"]),
      region: resolveFieldName(info.data, ["region"]),
      ind   : resolveFieldName(info.data, ["id_indicador","indicador_id"]),
      dvals : resolveFieldName(info.data, ["d_valores","d valores","descripcion_valor"]),
      rec   : resolveFieldName(info.data, ["valor_recuento","valor recuento","recuento","conteo"]),
      flag  : resolveFieldName(info.data, ["flag_coef_var","flag","coef_var_flag"])
    };
    if(Object.values(fields).some(v=>!v)) throw new Error("Campos requeridos no hallados.");
  }

  // ======= Serie (líneas) =======
  async function loadLine(){
    const baseOpt=baseOptionFactory(); chart.clear(); chart.setOption(baseOpt);

    const {anio, ambito, valor, region, ind, dvals, rec, flag} = fields;

    const where =
      `UPPER(${region})='${REGION_TOTAL}' AND UPPER(${ind})=UPPER('${INDICADOR_OBJ}') AND UPPER(${dvals})=UPPER('${D_VALORES}')`;

    const outFields = [anio,ambito,valor,rec].concat(flag?[flag]:[]).join(",");

    const res = await jsonp(tableUrl + "/query", {
      where, outFields, orderByFields: `${anio} ASC, ${ambito} ASC`,
      returnGeometry: "false", f: "json"
    }, 20000);

    const features = (res.data && res.data.features) || [];
    if(!features.length) throw new Error("La consulta no devolvió filas (serie). Verifica id_indicador y d_valores.");

    const raw = features.map(f=>f.attributes)
      .filter(r => r && r[anio] != null && r[ambito] != null && r[valor] != null)
      .map(r => ({
        anio: Number(r[anio]),
        ambito: up(r[ambito]),
        valor: Number(r[valor]),
        recuento: (r[rec]!=null ? Number(r[rec]) : null),
        flag: flag ? cleanFlag(r[flag]) : ''
      }));

    // 0..1 -> % si corresponde
    const maxRaw = Math.max(...raw.map(r=>r.valor));
    const scale = (maxRaw <= 1.5) ? 100 : 1;
    raw.forEach(r => r.valor = r.valor * scale);

    // agregación (ambito, anio): promedio %, suma recuento, consolidación flags
    const agg = new Map();
    raw.forEach(r=>{
      const key = r.ambito + "|" + r.anio;
      const cur = agg.get(key) || { sum:0, count:0, rec:0, flags:new Set() };
      cur.sum += r.valor; cur.count += 1;
      if(r.recuento!=null && !isNaN(r.recuento)) cur.rec += r.recuento;
      if(r.flag) cur.flags.add(r.flag);
      agg.set(key, cur);
    });
    const rows = Array.from(agg.entries()).map(([key, o])=>{
      const [amb, an] = key.split("|");
      return { ambito: amb, anio: Number(an), valor: o.sum / o.count, recuento: o.rec, flag: Array.from(o.flags).join('') };
    });

    // Mostrar TOTAL, URBANO, RURAL
    const VALID = new Set(['TOTAL','URBANO','RURAL']);
    const filtered = rows.filter(r => VALID.has(r.ambito));

    const years = Array.from(new Set(filtered.map(r=>r.anio))).sort((a,b)=>a-b).map(String);
    const byAmb = {}; filtered.forEach(r => { (byAmb[r.ambito] ||= []).push(r); });

    const seriesPrep = [];
    Object.entries(byAmb).forEach(([ambito, arr])=>{
      const mVal = new Map(arr.map(o=>[String(o.anio), o.valor]));
      const mRec = new Map(arr.map(o=>[String(o.anio), o.recuento]));
      const mFlg = new Map(arr.map(o=>[String(o.anio), o.flag]));
      const data = years.map(y => (mVal.has(y) ? Number(mVal.get(y)) : null));
      const valid = data.filter(v=>v!=null);
      const mean = valid.length ? valid.reduce((a,b)=>a+b,0)/valid.length : 0;
      const recByYear = {}; years.forEach(y=>{ if(mRec.has(y)) recByYear[y] = Number(mRec.get(y)); });
      const flagByYear= {}; years.forEach(y=>{ const f = mFlg.get(y); if(f) flagByYear[y] = f; });
      seriesPrep.push({ name: ambito, data, mean, recByYear, flagByYear });
    });

    // Orden: TOTAL → URBANO → RURAL
    const prefer = ["TOTAL","URBANO","RURAL"];
    seriesPrep.sort((a,b)=>{
      const ai = prefer.indexOf(a.name), bi = prefer.indexOf(b.name);
      if(ai!==-1 || bi!==-1){
        if(ai===-1) return 1;
        if(bi===-1) return -1;
        return ai-bi;
      }
      return (b.mean||0)-(a.mean||0);
    });

    // Colores y estilo
    const n = Math.max(1, seriesPrep.length);
    const minL = Math.max(18, baseHSL.l - 12);
    const maxL = Math.min(85, baseHSL.l + 26);
    const stepL = (i)=> Math.round(minL + (maxL - minL) * (i/(n-1 || 1)));

    const series = seriesPrep.map((s,i)=>{
      const col = hsl(baseHSL.h, baseHSL.s, stepL(i));
      const name = s.name;
      const lineType = name==="TOTAL" ? 'solid' : (name==="URBANO" ? 'dashed' : (name==="RURAL" ? 'dotted' : 'solid'));
      return {
        name,
        type: 'line',
        smooth: 0.25,
        showSymbol: true,
        symbol: 'circle',
        symbolSize: 6,
        lineStyle: { width: 2, color: col, type: lineType, cap:'round', join:'round' },
        itemStyle: { color: col },
        emphasis: { focus: 'series', scale: false },
        clip: true,
        data: s.data,
        _color: col,
        _recByYear: s.recByYear,
        _flagByYear: s.flagByYear
      };
    });

    // Leyenda con icono de línea
    const legendData = series.map(s => ({ name: s.name, icon: makeLegendLineIcon(s._color, s.lineStyle?.type || 'solid') }));

    // Eje Y con colchón
    const vals = seriesPrep.flatMap(s=>s.data).filter(v=>v!=null && isFinite(v));
    const vmin = Math.min(...vals), vmax = Math.max(...vals);
    const pad = Math.max((vmax - vmin) * 0.18, 1.2);
    const yMin = Math.max(0, Math.floor((vmin - pad) * 10)/10);
    const yMax = Math.min(105, Math.ceil ((vmax + pad) * 10)/10);

    const opt=baseOptionFactory();
    chart.setOption({
      ...opt,
      xAxis: { ...opt.xAxis, data: years },
      yAxis: { ...opt.yAxis, min: yMin, max: yMax, name: '%Pob. con Cl aceptable' },
      legend: { ...opt.legend, data: legendData },
      series
    });

    // Etiquetas para las líneas después de la animación (no altera la animación original)
    let labelsApplied=false;
    chart.off('finished');
    chart.on('finished', ()=>{
      if(labelsApplied) return; labelsApplied=true;
      const m=responsiveMetrics();
      chart.setOption({
        series: series.map(s=>({
          label:{
            show:true, position:'top', distance:8, fontSize:m.labelFont, color:'#111827',
            formatter: (p)=> (p.value==null||isNaN(p.value)) ? '' : `${nf1.format(+p.value)}%`
          },
          labelLayout:{ hideOverlap:true, moveOverlap:'shiftY' }
        }))
      });
    });

    // Click -> drilldown
    chart.off('click');
    chart.on('click', (ev)=>{
      if(ev.componentType==='series' && ev.seriesType==='line'){
        const year = String(ev.name);
        const amb  = up(ev.seriesName); // TOTAL / URBANO / RURAL
        const color= (chart.getOption().series[ev.seriesIndex]._color) || '#3b82f6';
        loadBars({year, amb, color}).catch(showErr);
      }
    });

    $loading.style.display = 'none';
    $err.style.display = 'none';
    $err.textContent = '';
  }

  // ======= Drilldown (barras por región) =======
  async function loadBars({year, amb, color}){
    const {anio, ambito, valor, region, ind, dvals, rec, flag} = fields;

    const ambForRegions = amb; // TOTAL/URBANO/RURAL

    const where =
      `UPPER(${ind})=UPPER('${INDICADOR_OBJ}') AND UPPER(${dvals})=UPPER('${D_VALORES}') AND ${anio}=${Number(year)} AND ` +
      `UPPER(${region})<>'${REGION_TOTAL}' AND UPPER(${ambito}) LIKE '%${ambForRegions}%'`;

    const outFields = [region, valor, rec].concat(flag?[flag]:[]).join(",");

    const res = await jsonp(tableUrl + "/query", {
      where, outFields, orderByFields: `${region} ASC`,
      returnGeometry: "false", f: "json"
    }, 20000);

    const features = (res.data && res.data.features) || [];
    if(!features.length) throw new Error(`Sin datos para ${ambForRegions} en ${year} (drilldown).`);

    const raw = features.map(f=>f.attributes)
      .filter(r => r && r[region] && r[valor]!=null)
      .map(r => ({
        region: norm(r[region]),
        valor: Number(r[valor]),
        recuento: (r[rec]!=null ? Number(r[rec]) : null),
        flag: flag ? cleanFlag(r[flag]) : ''
      }));

    // 0..1 -> % si aplica y agregación
    const maxRaw = Math.max(...raw.map(r=>r.valor));
    const scale = (maxRaw <= 1.5) ? 100 : 1;

    const agg = new Map();
    raw.forEach(r=>{
      const key = up(r.region);
      const cur = agg.get(key) || { name: r.region, sum: 0, count: 0, rec: 0, flags: new Set() };
      cur.sum += r.valor * scale;
      cur.count += 1;
      if(r.recuento!=null && !isNaN(r.recuento)) cur.rec += r.recuento;
      if(r.flag) cur.flags.add(r.flag);
      agg.set(key, cur);
    });
    const rows = Array.from(agg.values()).map(o => ({
      region: o.name,
      valor : o.sum / o.count,
      recuento: o.rec,
      flag: Array.from(o.flags).join('')
    }));
    rows.sort((a,b)=>b.valor-a.valor);

    const x = rows.map(r=>r.region);
    const y = rows.map(r=>r.valor);
    const recs  = rows.map(r=>r.recuento);
    const flags = rows.map(r=>r.flag || '');

    const opt=baseOptionFactory();
    chart.clear();
    chart.setOption({
      ...opt,
      legend:{ show:false },
      tooltip:{
        trigger:'axis', axisPointer:{ type:'shadow' }, confine:true,
        formatter:(params)=>{
          const p = params && params[0]; if(!p) return '';
          const idx = p.dataIndex;
          const flagSuf = flags[idx] ? String(flags[idx]) : '';
          const recHere = recs[idx];
          const pctTxt = `${nf1.format(+p.value)}%${flagSuf}`;
          const recTxt = (recHere==null || isNaN(recHere)) ? '' : ` - ${formatRecuento(recHere)}${flagSuf}`;
          return `${p.axisValueLabel}<br><b>${pctTxt}</b>${recTxt}`;
        }
      },
      title:{ left:'center', top:10, text:`Pob. con Cl residual ≥0.5 mg/L — ${ambForRegions} — ${year}` },
      xAxis:{ type:'category', data:x,
              axisLabel:{ interval:0, rotate:(x.length>22?50:(x.length>15?35:(x.length>10?20:0))), fontSize: responsiveMetrics().axisFont } },
      yAxis:{ type:'value', name:'%Pob. Cl aceptable', axisLabel:{ formatter:v=>nf1.format(v), fontSize: responsiveMetrics().axisFont }, scale:true },
      series:[{
        name:'Región',
        type:'bar',
        data:y,
        itemStyle:{ color: color },
        label:{ show:true, position:'top', distance:6, formatter:(p)=>`${nf1.format(+p.value)}%`, fontSize: responsiveMetrics().labelFont, color:'#111827' },
        labelLayout:{ hideOverlap:false }
      }],
      animation:true,
      animationDuration:900,
      graphic: backGraphic(color, async()=>{ try{ await loadLine(); }catch(e){ showErr(e); } })
    });

    // ESC para volver
    document.onkeydown = async (e)=>{ if(e.key === 'Escape'){ document.onkeydown = null; await loadLine().catch(showErr); } };

    $loading.style.display = 'none';
    $err.style.display = 'none';
    $err.textContent = '';
  }

  // ======= Orquestación =======
  function showErr(e){
    $loading.style.display = 'none';
    $err.style.display = 'block';
    $err.textContent = "Error: " + (e && e.message ? e.message : e);
    console.error(e);
  }

  (async function run(){
    try{
      $loading.style.display = 'flex';
      await initMeta();
      await loadLine();
    }catch(e){ showErr(e); }
  })();

  window.addEventListener('error', (ev)=>{ showErr(ev && ev.message ? ev.message : ev); }, true);
})();
</script>
</body>
</html>
